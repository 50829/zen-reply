# 0228_01 — 启动 UI 动画与布局问题调研 + 改进方案

**日期**：2026-02-28  
**Owner**：AI_Alpha  
**状态**：In Progress — Round 3（发现权限根因，准备实施最终修复）

---

## 问题现状

用户反馈启动时 UI 动画体验不佳，具体表现：

1. **"先弹出透明边框，再浮出黑色面板"**——两层视觉分裂：窗口一出现就是一个固定大小的透明矩形，内部深色玻璃面板再从下方 `y: 20` 滑入，产生一帧"空壳"闪烁。
2. **最外层透明容器尺寸固定**——FlipCard 外层 `div` 始终 `h-full w-full` 填满 Tauri 窗口，与内部面板尺寸无关。
3. **内容纵向过多时文字被遮挡**——flip 容器以 `flipHeight`（初值 `minHeight=280`）+ `overflow-hidden` 裁剪，内容超高时直接截断。

---

## 底层原因分析

### 分层结构（由外到内）

```
┌ Tauri Window (transparent, 600×450 初始, useAutoResizeWindow 动态调整) ┐
│                                                                        │
│ ┌ FlipCard outer div ─ h-full w-full overflow-hidden p-4 ──────────┐   │
│ │                                                                   │   │
│ │  ┌ motion.section (panelRef) ── y:20→0, opacity:0→1, scale:.95→1│   │
│ │  │                                                                │   │
│ │  │  ┌ motion.div ── height: flipHeight, rotateY: 0|180 ──────┐  │   │
│ │  │  │                                                          │  │   │
│ │  │  │  [Front face] absolute inset-x-0 top-0                  │  │   │
│ │  │  │    └ WorkArea: 外壳 rounded-[24px] border-white/30...   │  │   │
│ │  │  │                 内壳 bg-[#0d1117]/90 backdrop-blur       │  │   │
│ │  │  │                                                          │  │   │
│ │  │  │  [Back face]  absolute inset-x-0 top-0 rotateY(180)     │  │   │
│ │  │  │    └ SettingsPanel                                       │  │   │
│ │  │  └──────────────────────────────────────────────────────────┘  │   │
│ │  └────────────────────────────────────────────────────────────────│   │
│ └───────────────────────────────────────────────────────────────────┘   │
└────────────────────────────────────────────────────────────────────────┘
```

### 根因 1：两层视觉分裂（透明空壳闪烁）

**时序**：

```
t=0   Rust window.show()
        → Tauri 窗口变为可见，尺寸是上次关闭时的值（或初始 600×450）
        → HTML/CSS 已渲染：FlipCard outer div h-full w-full——立即可见的透明区域
        → motion.section 处于动画起点 { y:20, opacity:0, scale:0.95 }——不可见

t≈0-260ms  motion.section 逐帧执行入场动画 y:20→0, opacity:0→1, scale:0.95→1
           → 用户在前 ~100ms 看到"空的透明窗口"，然后面板从下方浮出
```

**核心矛盾**：FlipCard 的外层 `div` 是 `h-full w-full`，它的尺寸由 Tauri 窗口决定，与内部面板无关。在面板 opacity=0 的那几十毫秒里，整个窗口就是一个看得见的空白矩形。

**涉及代码**：
- [FlipCard.tsx](src/components/layout/FlipCard.tsx#L48) — 外层 div: `h-full w-full overflow-hidden p-4`
- [FlipCard.tsx](src/components/layout/FlipCard.tsx#L53-L57) — motion.section: `initial={{ y: 20, opacity: 0, scale: 0.95 }}`

### 根因 2：窗口尺寸与内容不同步

- `tauri.conf.json` 给出初始 `width:600, height:450`。
- `useAutoResizeWindow` 通过 `ResizeObserver` 监听 `panelRef`（motion.section），异步测量后调用 `setSize`。
- 但在入场动画期间，`panelRef` 的 `getBoundingClientRect()` 受 `scale:0.95` 和 `y:20` 影响，测量值不准确。
- 结果：窗口大小可能在动画结束后才调整正确，前期出现大小不匹配。

**涉及代码**：
- [useAutoResizeWindow.ts](src/hooks/useAutoResizeWindow.ts#L33-L39) — `panelHeight = panelRef.current?.getBoundingClientRect().height`（受动画 transform 影响）

### 根因 3：flip 容器固定高度 + overflow-hidden 导致截断

```tsx
// FlipCard.tsx
<div className="... overflow-hidden p-4">          // ← 外层裁剪
  <motion.div
    animate={{ height: flipHeight }}               // ← 动画高度
  >
    <div className="absolute inset-x-0 top-0">     // ← 绝对定位面
      {front}                                       // ← 内容自然高度可能 > flipHeight
    </div>
  </motion.div>
</div>
```

- `flipHeight` 初始值为 `minHeight`（280px），后续靠 `ResizeObserver` 测量并更新。
- 但 front face 是 `absolute` 定位，它**不参与父元素的高度计算**——ResizeObserver 测的是 `offsetHeight`，可以正常工作。
- 问题在于：从 `flipHeight` 被设为初始 280px 到 ResizeObserver 回调 fire 之间有一帧延迟。如果内容实际 400px，在那一帧里 content 被裁掉 120px。
- 更严重的是，当 `useAutoResizeWindow` 算出的窗口高度过小时（因为动画期间测量不准），整个 FlipCard 外层也被限高，形成二次裁切。

**涉及代码**：
- [FlipCard.tsx](src/components/layout/FlipCard.tsx#L30-L35) — `flipHeight` 初值 `minHeight`
- [FlipCard.tsx](src/components/layout/FlipCard.tsx#L48) — `overflow-hidden`

---

## 改进方案

### 方案总览

改进目标按优先级：
1. **P0**：消除"透明空壳闪烁"——窗口可见时面板必须已在位
2. **P1**：消除内容截断——面板高度应自适应内容，而非受动画中间态裁切
3. **P2**：窗口-面板尺寸同步——减少启动时窗口大小跳变

### 改动点 1：FlipCard 入场动画改为整体 fade + 微缩放（无位移）

**目的**：消灭 P0——面板出现时不再有 y 位移，不再在 opacity=0 时暴露空壳。

**当前**：
```tsx
initial={{ y: 20, opacity: 0, scale: 0.95 }}
animate={{ y: 0, opacity: 1, scale: 1 }}
```
面板从下方滑入，对用户来说就是"先看到空白，再看到面板飘进来"。

**改为**：
```tsx
initial={{ opacity: 0, scale: 0.97 }}
animate={{ opacity: 1, scale: 1 }}
transition={{ duration: 0.2, ease: [0.22, 1, 0.36, 1] }}
```

- 去掉 `y: 20` 位移，面板不再"从下面飘上来"。
- `scale` 只做 0.97→1 的微缩放（几乎不可见的呼吸感），主要靠 opacity 过渡。
- `duration` 可从 0.26s 缩短到 0.2s，因为不需要位移时间。
- **效果**：面板直接原地淡入，不会暴露空白背景。

**文件**：[FlipCard.tsx](src/components/layout/FlipCard.tsx)

### 改动点 2：FlipCard 外层取消 `h-full w-full`，改为 `min-h-full w-full`

**目的**：外层容器不再撑满整个窗口高度，而是随面板内容收缩。这样即使有一帧空白，视觉面积也很小。

**当前**：
```tsx
<div className="relative flex h-full w-full items-center justify-center overflow-hidden p-4">
```

**改为**：
```tsx
<div className="relative flex min-h-full w-full items-center justify-center p-4">
```

- `h-full` → `min-h-full`：不强制占满窗口高度，最小等于窗口高度。
- 移除 `overflow-hidden`：裁切由内层处理（见改动点 3），此处不再双重裁切。

**文件**：[FlipCard.tsx](src/components/layout/FlipCard.tsx)

### 改动点 3：Flip 容器高度测量改进——消除初始帧截断

**目的**：解决 P1——确保 `flipHeight` 从第一帧就等于内容实际高度，不出现 280→真实值的跳变。

**当前问题**：`flipHeight` 初始值为 `minHeight`(280)，而 `ResizeObserver` 在 mount 后一帧才 fire。

**方案**：

a) 在 `useEffect` 内同步执行首次测量（`measure()` 在 observer 创建前已调用），这已实现。但问题是 `front` 内容可能还没渲染完。加入 `useLayoutEffect` 替代 `useEffect`，保证在浏览器绘制前完成首次测量：

```tsx
// 将 useEffect → useLayoutEffect
useLayoutEffect(() => {
  const measure = () => {
    const fh = frontRef.current?.offsetHeight ?? 0;
    const bh = backRef.current?.offsetHeight ?? 0;
    const h = Math.max(fh, bh);
    if (h > 0) setFlipHeight(h);
  };
  measure(); // synchronous measurement before paint

  const observer = new ResizeObserver(measure);
  if (frontRef.current) observer.observe(frontRef.current);
  if (backRef.current) observer.observe(backRef.current);
  return () => observer.disconnect();
}, [isFlipped]);
```

b) 给 flip 容器的 height 动画加 `immediate` 初始帧——`motion.div` 首帧不动画，直接跳到目标高度：

```tsx
<motion.div
  className="relative w-full"
  style={{ transformStyle: "preserve-3d" }}
  initial={false}   // ← 首帧不执行 initial→animate 动画, 直接为 animate 值
  animate={{
    rotateY: isFlipped ? 180 : 0,
    height: flipHeight,
  }}
  transition={{
    rotateY: { type: "spring", stiffness: 70, damping: 16 },
    height: { type: "spring", stiffness: 170, damping: 24 },
  }}
>
```

**文件**：[FlipCard.tsx](src/components/layout/FlipCard.tsx)

### 改动点 4：useAutoResizeWindow 使用 `scrollHeight` 替代 `getBoundingClientRect`

**目的**：解决 P2——动画期间 `getBoundingClientRect` 受 CSS `scale`/`translate` 影响导致测量失真。

**当前**：
```tsx
const panelHeight = panelRef.current?.getBoundingClientRect().height ?? 0;
```

**改为**：
```tsx
const panelHeight = panelRef.current?.scrollHeight ?? 0;
```

`scrollHeight` 返回元素的内容高度（含溢出），不受 CSS 变换影响。这样在入场 scale:0.97 的动画期间也能拿到准确值。

**文件**：[useAutoResizeWindow.ts](src/hooks/useAutoResizeWindow.ts)

### 改动点 5（可选 P2）：调整 tauri.conf.json 初始窗口高度为 `minHeight`

**当前**：`height: 450`  
**改为**：`height: 280`（与 `WINDOW_MIN_HEIGHT` 一致）

这样窗口首次出现时不会比面板内容大太多。`useAutoResizeWindow` 随后向上增长。由于面板淡入时窗口已接近正确大小，视觉跳变更小。

**文件**：[tauri.conf.json](src-tauri/tauri.conf.json)

---

## 改动效果预期（前后对比）

| 维度 | 改前 | 改后 |
|---|---|---|
| 启动首帧 | 透明空壳 → 面板从下滑入 | 面板原地淡入，无空壳闪烁 |
| 内容截断 | flipHeight 从 280 跳到真实值，有一帧裁切 | useLayoutEffect + initial=false，首帧即准确高度 |
| 窗口大小 | getBoundingClientRect 受 scale 影响，延迟调整 | scrollHeight 不受 transform 影响，立即准确 |
| 初始窗口 | 450px，可能比面板大 | 280px，与 minHeight 一致，最小初始闪差 |

---

## 预期的改动文件

| 文件 | 改动性质 |
|---|---|
| `src/components/layout/FlipCard.tsx` | 动画参数 + 布局改 + useLayoutEffect |
| `src/hooks/useAutoResizeWindow.ts` | 测量方法替换 |
| `src-tauri/tauri.conf.json` | 初始窗口高度调整（可选） |

---

## 潜在风险

1. **`useLayoutEffect` 在 SSR 环境会警告**——本项目是 Tauri 桌面端，不涉及 SSR，无风险。
2. **`scrollHeight` 在面板内容为空时可能返回 0**——已有 `if (!panelHeight) return` 保护。
3. **去掉 `y` 位移后动画质感变化**——可通过微调 `scale` 幅度（0.97~0.98）和 `duration`（0.18~0.22s）来找到最佳手感。
4. **移除 FlipCard 外层 `overflow-hidden`**——需确认翻转动画时背面不会"溢出"可视区。WorkArea 和 SettingsPanel 本身已有 `rounded + overflow-hidden` 内部裁切，理论安全。如果翻转时有视觉飞出，可改为仅在 `isFlipped` 翻转动画进行中时临时加 `overflow-hidden`。

---

## 实际改动记录

### FlipCard.tsx（3 处改动）

1. **import**：`useEffect` → `useLayoutEffect`
2. **`useEffect` → `useLayoutEffect`**：高度测量在浏览器绘制前同步执行，消除首帧 flipHeight 跳变
3. **外层 div class**：`h-full w-full … overflow-hidden` → `min-h-full w-full`（去掉固定满高和双重裁切）
4. **motion.section initial**：`{ y: 20, opacity: 0, scale: 0.95 }` → `{ opacity: 0, scale: 0.97 }`（去掉 y 位移，改为原地淡入）
5. **motion.section animate**：删除 `y: 0`（已无需）
6. **motion.section transition duration**：`0.26` → `0.2`
7. **motion.div**：添加 `initial={false}`，首帧直接采用 animate 值，不做 height 动画

### useAutoResizeWindow.ts（1 处改动）

1. **测量方法**：`getBoundingClientRect().height` → `scrollHeight`，不受 CSS transform 影响

### tauri.conf.json（1 处改动）

1. **初始窗口高度**：`450` → `280`，与 `WINDOW_MIN_HEIGHT` 对齐

---

## 第二轮改动（截断 + 白色闪烁）

### 问题现象

1. 外层 Tauri 窗口截断内层黑色面板底部内容
2. 按 Alt+Space 时屏幕中央先出现白色矩形，再变透明

### 根因分析

**截断问题**：`useAutoResizeWindow` 观察 `panelRef.scrollHeight`。但 `panelRef`（motion.section）内部的 `motion.div` 被 Framer Motion 强制设了 `height: flipHeight`。在 `flipHeight` 尚未更新到正确值时，`scrollHeight` 读到的也是矮值，导致窗口高度 < 面板实际内容高度 → 截断。

**白色闪烁**：Windows 上 WebView2 默认背景为白色。`window.show()` 时 WebView 还没将 CSS `background: transparent` 生效，用户看到 1-2 帧白色。

### 改动记录

#### FlipCard.tsx
- 新增 `onContentHeightChange?: (height: number) => void` prop
- `useLayoutEffect` 测量到 front/back face 高度后，回调上报真实高度

#### useAutoResizeWindow.ts — 全面重构
- 不再接受 `panelRef` / `triggerKey`
- 改为暴露 `reportContentHeight(height)` 回调
- FlipCard 调用该回调上报内容真实高度（直接来自 `offsetHeight`，不受 Framer Motion 动画限制）
- 窗口大小通过 `requestAnimationFrame` 异步设置

#### App.tsx
- `useAutoResizeWindow` 返回 `{ reportContentHeight }`
- 传给 FlipCard 的 `onContentHeightChange` prop

#### lib.rs（Rust）
- 在 `setup` 中对 main 窗口调用 `set_background_color(Some(tauri::window::Color(0, 0, 0, 0)))` 消除白色闪烁

### 潜在风险
1. `set_background_color` 在 Windows WebView2 上依赖底层支持，部分旧版 WebView2 可能无效——降级为无害（白闪一帧）
2. `reportContentHeight` 回调作为 `useLayoutEffect` 依赖可能导致额外渲染——实际上回调是 `useCallback` 的稳定引用，不会触发循环

## 潜在风险

1. 去掉外层 `overflow-hidden` 后，3D 翻转时如果 back face 内容过高，可能超出窗口边界——内层组件本身有 `overflow-hidden`，理论安全。
2. `scrollHeight` 在面板内容为空时返回 0——已有 `if (!panelHeight) return` 保护。
3. 去掉 `y` 位移后动画感知变轻——可后续微调 `scale` 和 `duration`。

---

## Round 3 调研结论 — 2026-02-28 下午

### 一、Tauri v2 外层窗口能否动态改变大小？

**结论：完全可以。** Tauri v2 提供以下 JavaScript API 供前端动态调整窗口：

| 方法 | 说明 |
|---|---|
| `window.setSize(LogicalSize)` | 设置窗口 inner size（对无装饰窗口等于 outer size） |
| `window.setMinSize(LogicalSize)` | 设置最小内尺寸约束 |
| `window.setMaxSize(LogicalSize)` | 设置最大内尺寸约束 |
| `window.setResizable(bool)` | 运行时切换是否可拖拽调整 |
| `window.show()` / `window.hide()` | 控制窗口可见性 |
| `window.setFocus()` | 窗口聚焦 |

Rust 端也有等价方法（`Window::set_size`, `Window::set_min_size` 等）。

**关键限制**：这些 JS 方法底层走 Tauri IPC → `core:window:*` 命令。**必须在 Capabilities 文件中授权，否则静默失败。**

### 二、根因确认 — 权限缺失

当前 `capabilities/default.json` 仅包含 `core:default`，其中：
- `core:window:default` 只授予**只读**权限（`allow-inner-size`, `allow-is-resizable`, `allow-title` 等）
- **不含** `allow-set-size`, `allow-set-min-size`, `allow-set-max-size`, `allow-set-resizable`, `allow-show`, `allow-set-focus`

这意味着 `useAutoResizeWindow` 中的所有 `setSize()`, `setMinSize()`, `setMaxSize()`, `setResizable()` 调用**一直在报权限错误**，但被 `catch {}` 静默吞掉。窗口从启动到关闭始终保持 `tauri.conf.json` 中配置的初始尺寸（280px），永远不会自动调整。

### 三、修复方案

#### 方案 A — 窗口可变尺寸（推荐，当前架构方向）

1. **[关键] 补全权限**：在 `capabilities/default.json` 中添加：
   ```
   "core:window:allow-set-size",
   "core:window:allow-set-min-size",
   "core:window:allow-set-max-size",
   "core:window:allow-set-resizable",
   "core:window:allow-show",
   "core:window:allow-set-focus",
   "core:window:allow-unminimize",
   "core:window:allow-center"
   ```

2. **延迟 `window.show()` 到 JS 端**：Rust 端只 emit 事件，不调 `show()`。JS 端在 `setSize()` 完成后再 `show()` + `setFocus()`。这可解决：
   - 透明边框先于面板出现的闪烁
   - 首次启动时只有外框没有内容的 Bug

3. **精简 `useAutoResizeWindow`**：每次只调 `setSize()`，不必重复调 `setResizable()` / `setMinSize()` / `setMaxSize()`。约束在 `tauri.conf.json` 配置即可。

4. **`tauri.conf.json` 补充 `shadow: false`**：Windows 11 上无装饰+透明窗口+shadow=true 会产生 1px 白色边框，就是用户看到的"透明外框"。

#### 方案 B — 窗口固定尺寸（替代方案，不推荐）

如果不希望窗口动态调整，可以：
1. 固定窗口为足够大的尺寸（如 600×700）
2. 内容区域在窗口内自由排列，多余空间透明
3. 面板底部使用内部滚动条（`overflow-y: auto`）

缺点：透明区域可能遮挡桌面交互；窗口 shadow 边框始终可见于固定范围；浪费屏幕空间。

### 四、实施清单

| 文件 | 改动 |
|---|---|
| `capabilities/default.json` | 添加 8 个 `core:window:allow-*` 权限 |
| `lib.rs` | `on_shortcut_pressed` 中移除 `show() / unminimize() / set_focus()` |
| `useAutoResizeWindow.ts` | `setSize()` 后调 `show()` + `setFocus()`；精简冗余 API 调用 |
| `tauri.conf.json` | 添加 `shadow: false`；补充 `minWidth/minHeight/maxHeight` |
| `index.css` | 无需改动（保持 `overflow: hidden` 防滚动条） |

