## 0228_09 — 启动速度与入场动画重构

### 问题

1. **启动慢**：快捷键触发后到窗口可见存在明显延迟
2. **无渐入**：窗口突然出现，缺少入场动画，视觉突兀

### 根因分析

#### 旧启动时序（从快捷键释放到用户可见）

```
Rust: Alt+Space released
  → spawn thread → clipboard capture (~80-130ms)
  → emit CLIPBOARD_EVENT

JS: onWake() → setIsAwake(true) → React render FlipCard
  → framer-motion mounts <motion.section> with initial={{ opacity: 0, scale: 0.97 }}
  → ResizeObserver fires → reportContentHeight()
  → await setSize()          ← IPC #1
  → await center()           ← IPC #2
  → await show()             ← IPC #3
  → await setFocus()         ← IPC #4
  → framer-motion 开始 200ms mount 过渡（但窗口已显示，动画已进行到中途）
```

**瓶颈**：
- 4 次顺序 `await` IPC 调用（每次 ~2-5ms 跨进程往返），总计 ~10-20ms 额外延迟
- framer-motion 的 `initial → animate` 过渡在 React hydration 后才开始，但窗口在 `show()` 后已可见 → 用户可能看到动画的中间态而非开头
- `set_background_color(Color(0,0,0,0))` 在 Windows 上 alpha 通道被忽略（Tauri 文档明确说明），是无效代码

#### 入场动画问题

framer-motion 的 mount 动画 (`initial={{ opacity: 0, scale: 0.97 }}`) 需要：
1. React 完成渲染
2. framer-motion 读取 DOM 布局
3. 开始 JS 驱动的逐帧动画

这意味着 JS 引擎 + framer-motion 调度是动画开始的前提条件。如果窗口在此之前就 `show()` 了，用户看到的第一帧可能不是 opacity:0 而是某个中间值。

### 解决方案

#### 1. Rust 侧：单 IPC 命令 `show_window`

新增 `show_window(width, height)` 命令，在 Rust 侧同步完成：
```
setSize → center → show → setFocus → update_tray_menu
```
JS 侧只需一次 `invoke("show_window", { width, height })` 调用。

#### 2. CSS `@starting-style` 取代 framer-motion mount 动画

Tailwind CSS v4 / WebView2 (Chromium 117+) 完全支持 `@starting-style`。

核心原理：浏览器在元素**首次渲染前**就知道起始样式，因此动画从第一帧就正确播放。不需要 JS 参与，不需要等待 React hydration。

```css
.zen-panel-enter {
  opacity: 1;
  scale: 1;
  transition: opacity 0.18s cubic-bezier(0.22, 1, 0.36, 1),
              scale 0.18s cubic-bezier(0.22, 1, 0.36, 1);
  @starting-style {
    opacity: 0;
    scale: 0.97;
  }
}
```

当 `<section class="zen-panel-enter">` 插入 DOM 时，浏览器自动从 `opacity:0 scale:0.97` 过渡到 `opacity:1 scale:1`，时序与 `show()` 完美对齐。

#### 3. 移除无效的 `set_background_color`

Windows WebView2 的 `set_background_color` 忽略 alpha 通道。窗口透明已由 `tauri.conf.json` 的 `transparent: true` 保证，该调用为死代码。

### 新启动时序

```
Rust: Alt+Space released
  → spawn thread → clipboard capture (~80-130ms)
  → emit CLIPBOARD_EVENT

JS: onWake() → setIsAwake(true) → React render FlipCard
  → <section class="zen-panel-enter"> 插入 DOM
  → CSS @starting-style 立即开始 opacity+scale 过渡（浏览器原生，零 JS 开销）
  → ResizeObserver fires → reportContentHeight()
  → invoke("show_window", { width, height })    ← 单次 IPC
  → Rust: setSize + center + show + setFocus     ← 同步完成
  → 窗口可见，CSS 动画已在播放中
```

**改善**：
- IPC 从 4 次顺序 → 1 次
- 入场动画从 JS 驱动 → 浏览器原生 CSS，零调度延迟
- 动画在 DOM 插入时即开始，不需等待 JS 引擎

### Changelog

#### `src-tauri/src/lib.rs`
1. 新增 `show_window(width, height)` 命令：单 IPC 完成 setSize + center + show + setFocus + update_tray_menu
2. 注册到 `invoke_handler`
3. 删除无效的 `set_background_color(Color(0,0,0,0))` 调用

#### `src-tauri/capabilities/default.json`
4. 新增 `core:window:allow-is-visible` 权限

#### `src/hooks/useAutoResizeWindow.ts`
5. 首次报告路径：4 次顺序 IPC → `invoke("show_window")` 单次调用
6. 后续 resize 仍使用 JS `setSize()` 保持轻量

#### `src/components/layout/FlipCard.tsx`
7. `<motion.section>` → `<section class="zen-panel-enter">`
8. 删除 `initial`/`animate`/`transition` mount 动画 props
9. 删除 `MOUNT_TRANSITION` 导入

#### `src/index.css`
10. 新增 `.zen-panel-enter` 类：CSS `@starting-style` 实现 opacity+scale 入场动画

#### `src/shared/motion.ts`
11. 删除 `MOUNT_TRANSITION` 常量（已无消费者）
12. 删除 `EASE_SMOOTH` 常量（已无消费者）

### Verification

- `tsc --noEmit` — 零类型错误 ✅
- `bun run build` — 通过 ✅
- `cargo check` — 通过 ✅
- `cargo build` — 通过 ✅
