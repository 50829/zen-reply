# 0228_02 — 系统托盘功能方案设计

**日期**：2026-02-28  
**Owner**：AI_Beta  
**状态**：Research

---

## 问题现状

当前 ZenReply 通过 `Alt+Space` 唤醒面板，`Esc` 隐藏窗口并重置状态。应用进程始终保持运行，但用户无法从视觉上确认应用是否仍在后台运行，也无法通过除 `Alt+Space` 之外的方式唤出窗口。

**用户需求**：

1. `Esc` 按下后，窗口最小化到系统托盘（而非仅隐藏）
2. 左键单击托盘图标恢复窗口
3. 右键托盘图标弹出菜单：打开主面板 / 打开设置 / 退出程序

---

## 底层原因分析

### 现有架构关键点

1. **窗口生命周期**：Tauri 窗口 `visible: false`（初始隐藏），`decorations: false`（无标题栏/关闭按钮），`transparent: true`。
2. **Esc 行为**：`useGlobalShortcuts` → `terminateSession()` → `stopStream + resetFlow + hide_window`，会完全重置 UI 状态（`isAwake = false`）。
3. **唤醒流程**：唯一入口是 `Alt+Space` → Rust `on_shortcut_pressed` → 剪贴板捕获 → `window.show()` → `emit(clipboard-text)` → 前端 `onWake(text)`。
4. **状态管理**：纯 React hooks，无外部状态库。`isAwake` 控制 FlipCard 是否渲染。

### 缺失能力

- 无系统托盘图标——用户无法感知应用在后台运行
- 无托盘交互——无法通过托盘恢复窗口或触发操作
- 无 "关闭保护"——Windows 任务管理器/任务栏可直接杀进程，缺少 "最小化到托盘而非退出" 的兜底

---

## 功能方案

### 1. 整体行为设计

| 触发方式 | 行为 | 是否重置 UI 状态 |
|---|---|---|
| `Esc`（设置面板打开时） | 关闭设置面板，**不隐藏窗口** | 否（现有行为不变） |
| `Esc`（主面板 / 其他状态） | 隐藏窗口到托盘 + 重置 UI 状态 | **是**（与现有行为一致） |
| `Alt+Space` | 剪贴板捕获 + 唤醒面板（现有行为不变） | 是（`onWake` 重置） |
| 左键单击托盘 | 显示窗口 + 以空文本唤醒进入 INPUT 状态 | 是（等效于无文本的 wake） |
| 右键托盘 → "打开主面板" | 同左键行为 | 是 |
| 右键托盘 → "打开设置" | 显示窗口 + 唤醒 + 自动翻转到设置面板 | 是（wake + flip，React 18+ 批处理保证单次渲染，用户视觉上是一步到位直接出现设置面） |
| 右键托盘 → "退出程序" | 彻底退出进程 | N/A |
| Windows 任务栏关闭 / `CloseRequested` | 拦截关闭 → 隐藏到托盘 + 重置 | 是（同 Esc 行为） |

> **设计原则**：托盘功能不改变现有 `Esc` 重置语义，而是增量添加。`Esc` 仍然是 "结束当前会话"，托盘只是让用户可以用鼠标重新唤醒，同时提供退出入口。

### 2. 新增事件定义

| 事件名 | 方向 | 载荷 | 含义 |
|---|---|---|---|
| `zenreply://tray-wake` | Rust → React | `{}` | 托盘唤醒主面板（空文本） |
| `zenreply://tray-open-settings` | Rust → React | `{}` | 托盘唤醒 + 打开设置面板 |

### 3. Rust 侧实现方案

#### 3.1 依赖变更（`Cargo.toml`）

```toml
tauri = { version = "2", features = ["tray-icon"] }
```

#### 3.2 托盘初始化（`lib.rs` → `setup` 闭包）

```rust
use tauri::tray::{MouseButton, MouseButtonState, TrayIconBuilder, TrayIconEvent};
use tauri::menu::{MenuBuilder, MenuItemBuilder};

// In setup closure:
let show_item = MenuItemBuilder::with_id("show", "打开主面板").build(app)?;
let settings_item = MenuItemBuilder::with_id("settings", "打开设置").build(app)?;
let quit_item = MenuItemBuilder::with_id("quit", "退出程序").build(app)?;

let menu = MenuBuilder::new(app)
    .items(&[&show_item, &settings_item, &quit_item])
    .build()?;

TrayIconBuilder::new()
    .icon(app.default_window_icon().unwrap().clone())
    .tooltip("ZenReply")
    .menu(&menu)
    .on_menu_event(|app, event| {
        let window = app.get_webview_window("main");
        match event.id().as_ref() {
            "show" => {
                if let Some(w) = window {
                    let _ = w.show();
                    let _ = w.unminimize();
                    let _ = w.set_focus();
                    let _ = w.emit("zenreply://tray-wake", ());
                }
            }
            "settings" => {
                if let Some(w) = window {
                    let _ = w.show();
                    let _ = w.unminimize();
                    let _ = w.set_focus();
                    let _ = w.emit("zenreply://tray-open-settings", ());
                }
            }
            "quit" => {
                app.exit(0);
            }
            _ => {}
        }
    })
    .on_tray_icon_event(|tray, event| {
        if let TrayIconEvent::Click {
            button: MouseButton::Left,
            button_state: MouseButtonState::Up,
            ..
        } = event
        {
            let app = tray.app_handle();
            if let Some(window) = app.get_webview_window("main") {
                let _ = window.show();
                let _ = window.unminimize();
                let _ = window.set_focus();
                let _ = window.emit("zenreply://tray-wake", ());
            }
        }
    })
    .build(app)?;
```

#### 3.3 窗口关闭拦截

在 `run()` 函数中，链式调用 `on_window_event` 防止窗口被意外关闭：

```rust
tauri::Builder::default()
    // ...existing plugins...
    .setup(|app| { /* ...existing + tray setup... */ })
    .on_window_event(|window, event| {
        if let tauri::WindowEvent::CloseRequested { api, .. } = event {
            // Prevent actual close — hide to tray instead.
            api.prevent_close();
            let _ = window.hide();
        }
    })
    .invoke_handler(...)
    .run(...)
```

### 4. 前端侧实现方案

#### 4.1 `useZenReplyFlow.ts` — 监听托盘事件

在现有的 `useEffect`（监听剪贴板事件）中，新增两个监听器：

```typescript
const TRAY_WAKE_EVENT = "zenreply://tray-wake";
const TRAY_OPEN_SETTINGS_EVENT = "zenreply://tray-open-settings";

// Inside the existing useEffect that sets up listeners:
const unlistenTrayWake = await listen(TRAY_WAKE_EVENT, () => {
  onWake("");  // Wake with empty text, enter INPUT stage
});

const unlistenTraySettings = await listen(TRAY_OPEN_SETTINGS_EVENT, () => {
  onWake("");  // Wake first
  settings.setIsSettingsOpen(true);  // Then flip to settings
});

// Cleanup:
return () => {
  // ...existing cleanup...
  unlistenTrayWake();
  unlistenTraySettings();
};
```

#### 4.2 `useGlobalShortcuts.ts` — Esc 行为不变

`Esc` 仍调用 `terminateSession()`，行为完全不变。托盘图标始终可见，不受窗口显隐影响。无需修改此文件。

### 5. 权限与配置

#### 5.1 `capabilities/default.json`

Tauri v2 的托盘功能由 core 提供，通常不需要额外权限声明。`core:default` 已覆盖。但需要确认菜单相关权限：

```json
{
  "permissions": [
    "core:default",
    "opener:default",
    "clipboard-manager:allow-read-text",
    "clipboard-manager:allow-write-text",
    "store:default",
    "menu:default"
  ]
}
```

> 注：若 `core:default` 已包含 `menu:default`，则无需额外添加。编译时验证。

#### 5.2 `tauri.conf.json`

**不需要修改**。托盘完全通过 Rust 代码（`TrayIconBuilder`）动态创建，避免与 0228_01 任务的文件锁冲突。

### 6. 托盘图标

使用现有 `icons/icon.png`（或 `32x32.png`）作为托盘图标。`app.default_window_icon()` 会自动读取 `tauri.conf.json` → `bundle.icon` 配置的图标，无需额外文件。

---

## 预期的改动点

| 文件 | 改动类型 | 说明 |
|---|---|---|
| `src-tauri/Cargo.toml` | 修改 | 添加 `tray-icon` feature |
| `src-tauri/src/lib.rs` | 修改 | 添加 tray 初始化 + 菜单 + 事件处理 + 窗口关闭拦截 |
| `src-tauri/capabilities/default.json` | 可能修改 | 添加 `menu:default` 权限（如有需要） |
| `src/hooks/useZenReplyFlow.ts` | 修改 | 监听 `tray-wake` 和 `tray-open-settings` 事件 |

### 文件锁定范围（Scope）

```
src-tauri/Cargo.toml
src-tauri/src/lib.rs
src-tauri/capabilities/default.json
src/hooks/useZenReplyFlow.ts
```

### 冲突检查

- 0228_01 锁定：`FlipCard.tsx`, `useAutoResizeWindow.ts`, `App.tsx`, `tauri.conf.json`, **`lib.rs`**
- 本任务锁定：`Cargo.toml`, **`lib.rs`**, `default.json`, `useZenReplyFlow.ts`
- ⚠️ **`src-tauri/src/lib.rs` 存在冲突**——需等待 0228_01 完成或用户手动调整优先级后方可实施

---

## 潜在风险

1. **Tauri v2 `tray-icon` feature 编译**：首次启用该 feature 可能触发较长的增量编译。
2. **`app.default_window_icon()` 在开发模式下可能为 `None`**：需要 fallback 处理，或直接用 `include_bytes!` 内嵌图标。
3. **托盘事件时序**：`tray-open-settings` 事件中先 `onWake("")` 再 `setIsSettingsOpen(true)` 需确保是同步生效的（React 18+ 自动批处理保证）。
4. **Windows 特定行为**：Windows 系统托盘区域可能需要用户手动将图标 "显示在任务栏" 而非折叠到溢出区域。这是 OS 层面设置，应用无法控制。
5. **`CloseRequested` 拦截**：需确保 "退出程序" 菜单项调用 `app.exit(0)` 能绕过拦截（Tauri 的 `exit()` 不触发 `CloseRequested`，直接终止进程）。

---

## 状态机更新（对 PROJECT_SPEC §3.4 的增量补充）

```
         ┌───── Alt+Space (onWake) ─────┐
         │                              │
         ▼                              │
      INPUT ──── startGenerating ──► GENERATING
         ▲                              │
         │                              ▼
         │                          FINISHED
         │                              │
         └──────── confirmAndCopy ──────┘
                   (→ hide → reset)

      任意状态 ──── Esc ──► terminateSession ──► hide to tray + reset
      
      [NEW] 托盘左键 / "打开主面板" ──► show window + onWake("") ──► INPUT
      [NEW] 托盘 "打开设置" ──► show window + onWake("") + flip to settings
      [NEW] 托盘 "退出程序" ──► app.exit(0)
      [NEW] CloseRequested ──► prevent close → hide to tray
```

---

## 键盘/交互速查更新

| 操作 | 行为 |
|---|---|
| `Esc` | 隐藏到托盘 + 重置状态（行为不变，语义补充） |
| 托盘左键单击 | 显示窗口，进入空白 INPUT 状态 |
| 托盘右键 → 打开主面板 | 同左键 |
| 托盘右键 → 打开设置 | 显示窗口 + 自动翻转到设置 |
| 托盘右键 → 退出程序 | 彻底退出进程 |
